import { useEffect, useState } from 'react';
import './App.css';
import { BrowserProvider} from 'ethers';
import { ethers } from 'ethers';
// Import the types generated by the TypeChain library when working with the final version of your contract.
import { Counter__factory} from './generated/contract-types';

declare let window: any

function App() {

  const [address, setAddress] = useState<string>();
  const [provider, setProvider] = useState<BrowserProvider>();
  const [balance, setBalance] = useState<string>();
  const [num, setNum] = useState<bigint>();
  const [newNum, setNewNum] = useState<number | undefined>(undefined);
  const [slicedWords, setSlicedWords] = useState<string[]>();
  const CONTRACT_ADDRESS = '0x58C32Fd357939a1C57070cCd26726C0b1F5Cdc5c'

  //step one connect wallet
  const handleConnectWallet = async () => {
    try {
      const myProvider = new ethers.BrowserProvider(window.ethereum);
      setProvider(myProvider); // Set the provider state
      if (provider) {
        await provider.send('eth_requestAccounts', []);
        const signer = await provider.getSigner();
        const connectedAddress = await signer.getAddress();
        setAddress(connectedAddress);
      }

      //getNumber();
    } catch (error) {
      console.error('Error connecting wallet:', error);
    }
  };

  //step 2 get wallet ballance
  const getBalance = async () => {
    if (provider && address) {
      try {
        const formattedBalance = ethers.formatEther(await provider.getBalance(address));
        setBalance(formattedBalance);
      } catch (error) {
        console.error('Error fetching balance:', error);
      }
    }
  };

  useEffect(() => {
    if (provider && address) {
      getBalance();
    }
  }, [provider, address]);

  //step 3 get number public value with JasonRPC
  const getNumber = async () => {
    const provider = new ethers.JsonRpcProvider()
    const counter = Counter__factory.connect(CONTRACT_ADDRESS, provider)
    const number = await counter.number() 
    setNum(number)
  }

  // handle set number
  const setNumberInContract = async (newNumber: number) => {
    if (provider && newNumber !== undefined) {
      try {
        const signer = await provider.getSigner();
        const counter = Counter__factory.connect(CONTRACT_ADDRESS, signer);

        const transaction = await counter.setNumber(newNumber);

        // Wait for the transaction to be mined
        await transaction.wait();

        // After the transaction is mined, you can fetch the updated number if needed
        const updatedNumber = await counter.number();
        setNum(updatedNumber);

        getBalance();

      } catch (error) {
        console.error('Error setting number:', error);
      }
    }
  };
  
  //call sliceword function
  const getWordSlice = async () => {
    if (provider && num !== undefined) {
      try {
        const signer = await provider.getSigner();
        const counter = Counter__factory.connect(CONTRACT_ADDRESS, signer);
  
        const wordSlice = await counter.getSlice(Number(num));
        setSlicedWords(wordSlice); // Update the state with the sliced words
      } catch (error) {
        console.error('Error getting word slice:', error);
      }
    }
  };
  

  return (
    <>
    <br />
    <div className="App">
      {address ? (
            <>
            {/*After connection, the address and current balance of the wallet must be displayed*/}
              <div>{address}</div>
              <div>{balance}</div>
            </>
          ) : (
            //A connect button when pressed will invoke MetaMask wallet and connect to the blockchain
            <button onClick={handleConnectWallet}>Connect Wallet</button>
          )}
    </div>
    <br />
    <div className='App'>
    {/*A button to call getNum from the smart contract*/}
        <button onClick={getNumber}>Get Latest Number</button>
        <h3>Number: {Number(num)}</h3>
        <input
  type="number"
  placeholder="Enter a new number"
  onChange={(e) => {
    // Parse the input value as a number
    const newValue = Number(e.target.value);
    
    // Enforce minimum and maximum values
    if (newValue < 0) {
      setNewNum(0); // Minimum value of 0
    } else if (newValue > 10) {
      setNewNum(10); // Maximum value of 10
    } else {
      setNewNum(newValue);
    }
  }}
  min="0"  // Minimum value
  max="10" // Maximum value
/>

        <button onClick={() => setNumberInContract(newNum as number)}>Set Number</button>
    </div>
    <br />
    

    <div className='App'>
  <button onClick={getWordSlice}>Get Word Slice</button>
  {slicedWords && (
    <ul>
      {slicedWords.map((word, index) => (
        <li key={index}>{word}</li>
      ))}
    </ul>
  )}
</div>
<br />
    </>
  );
}

export default App;